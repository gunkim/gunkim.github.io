---
layout: learn
title: 03.Garbage Collection
tags: [ "Book" ]
categories: java-performance-fundamental
---

## Garbage Collection이란?

> 객체에 대한 힙 저장소는 자동 저장 관리 시스템(일반적으로 가비지 컬렉터)에 의해 회수되며, 객체는 명시적으로 할당 해제되지 않습니다.  
> -Java Virtual Machine 명세, 섹션 3.5.3 [VMS2 1999]

프로그램을 수행하는 과정에서 잠시 멈추기도 하고, CPU 사용에 민감한 프로그램의 경우 CPU Time 스케줄링에 어려움을 주기도 한다.

JVM 각 벤더는 여러 Garbage Collector를 제공하고 있기 때문에 어떤 Garbage Collector를 선택하느냐도 성능에 있어서 중요한 이슈가 된다.

## Garbage Collection의 대상

Garbage Collection은 Garbage를 모으는 작업이다. 여기서 Garbage란 Heap과 Method Area에서 사용되지 않는 Object를 의미한다.

이 때 Garbage Collection은 현재 사용되지 않는 Object를 Garbage로 판단하고 있다. 현재 사용 여부는 Root Set과의 관계로 판단한다.
어떤 식으로든 Reference 관계가 있다면 Reachable Object라고 하고, 현재 사용되고 있는 Object로 간주한다.

Root Set은 보통 3가지로 구분한다.
- Stack의 참조 정보이다.
  - Local Variable Section과 Operand Stack에 Object의 Reference 정보가 있다면 Reachable Object이다.
  - 여기서 Reachable Object는 현재 Thread들이 사용하고 있는 것으로 간주된다.
- Method Area에 Loading된 Class, 그 중에서 Constant Pool에 있는 Reference 정보이다.
  - 이 정보는 Thread에서 직접 참조하고 있지 않지만 Constant Pool을 통해 간접 Link하고 있는 Reachable Object이다.
- 아직 메모리에 남아 있는 Native Method로 넘겨진 Object Reference이다.
  - JNI 형태로 현재 참조 관계까 있는 Object이기 때문에 Reachable Object이다.

이 세 가지 Reference 정보에 의해 직간접적으로 참조되고 있다면 모두 Reachable Object이고, 그렇지 않은 것은 모두 Garbage Object로 간주되어 Garbage Collection의 대상이 된다. 

아래 그림을 보면 Root Set과 어떤 식으로든 링크가 되어 있는 것은 Reachable Object의 영역 안에 포함된다. 그리고 가장 상단에는 Root Set과 관계없이 상호 참조만을 하고 있는 Object를 볼 수 있는데, Garbage Collector는 이를 Garbage로 판단한다.

![](/public/img/learn/java-performance-fundamental/03-1.png)

그림에서 Reachable Object But not Live는 참조는 존재하지만, 실제로는 사용되지 않는 객체를 말한다. 즉 Memory Leak이라고 볼 수 있다.

Garbage Collection은 보통 메모리가 부족할 때 수행되게 된다. 새로운 Object 할당을 위해 Heap을 재활용하기 위한 목적으로 볼 수 있다.


Garbage Collection이 수행된 후 메모리는 듬성듬성할 수 밖에 없다.
이 경우 메모리에 개별 Free Space의 크기보다 큰 Object를 할당할 경우 재활용의 의미가 사라진다.

아래 그림에서 GC가 수행되어 총 6KB의 공간이 새로 생겼다. 하지만 5KB의 Object를 할당할 순 없다. 최대 3KB가 최대일 것이다.
이 현상을 Heap의 단편화라고 하며 Gabage Collector는 Compaction과 같은 알고리즘을 사용하고 있다.

![](/public/img/learn/java-performance-fundamental/03-2.png)

결국 Garbage Collection은 Heap을 재활용하기 위해 Root Set에서 참조되지 않는 Object를 없애는 작업이라고 할 수 있다.

## Garbage Collection의 기본 알고리즘

이 장에서는 6가지의 알고리즘을 통해 Garbage Collection의 동작 원리를 이해하는 것이 핵심이다.
- Reference Counting Algorithm
- Mark-and-Sweep Algorithm
- Mark-and-Compacting Algorithm
- Copying Algorithm
- Generational Algorithm
- Train Algorithm

### Reference Counting Algorithm

Garbage Object를 찾아내는 Detection에 초점이 맞추어진 Algorithm이다.

초기 Algorithm답게 각 Object마다 Reference Count를 관리하여 Reference Count가 0이 되면 그때 Garbage Collection을 수행하도록 단순하게 구성되어 있다.

Reference Count Algorithm은 Reference Count가 0인 것만 확인하면 되기 때문에 Garbage Object를 확인하는 작업이 매우 간단하다.
그렇기 때문에 Pause Time이 분산되어 실시간 작업에도 거의 영향을 주지 않는 장점이 잇다.

하지만 Reference가 변경될 때마다 각 Object마다 Reference Count를 변경해주어야 하기 때문에 이에 대한 관리 비용이 상당하다. 또한 Garbage Collectrion이 연쇄적으로 일어날 수 있다는 것도 문제가 될 수 있다.

또한 순환 참조의 경우 Reference Count가 0이 될 가능성이 희박하기 때문에 Memory Leak을 유발할 가능성이 커진다.

### Mark-and-Sweep Algorithm

Tracing Algorithm이라고도 불리며 Reference Counting Algorithm의 단점을 극복하기 위해 나왔다.

앞선 Counting 방식이 아니라 Root Set에서 시작하는 Reference 관계를 추적하는 방식을 사용한다.
이 방식은 Garbage를 찾아내는데 상당히 효과적이기 때문에 이후의 Garbage Collection에서는 대부분 이 Algorithm을 사용하고 있다.

Mark Phase와 Sweep Phase 단계로 나뉜다.

Mark Phase는 Garbage Object를 구별해내는 단계로 Root Set에서 Reference 관계가 있는 Object에 Marking하는 방식으로 수행된다. Marking하기 위해 주로 Object Header에 Flag나 별도의 Bitmap Table 등을 사용한다.
